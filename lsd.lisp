q(defpackage #:lsd
  (:use #:cl)
  (:export #:main))
(in-package #:lsd)

(defparameter *game*
  (list :title "Lazy Sweet Dream"
        :version (asdf:component-version (asdf:find-system :lsd))
        :width 800
        :height 600))

(defparameter *entity-count* 0)
(defun make-entity-id ()
  (prog1 *entity-count*
    (incf *entity-count*)))

(defstruct point id x y)
(defstruct velocity id x y)
(defstruct direction id r)
(defstruct vanish id x y w h)
(defstruct otype id name)
(defstruct input id u d l r s z)
(defstruct used id bool)
(defstruct script id code ip stack)

(defstruct shooter
  tick
  database
  points vels dirs vanishes types inputs used)

(defun make-entity (db type &rest keys &key &allow-other-keys)
  (let* ((maker-name (intern (format nil "MAKE-~a" (symbol-name type)) :lsd))
         (maker (symbol-function maker-name))
         (id-name (intern (format nil "~a-ID" (symbol-name type)) :lsd))
         (getter-id (symbol-function id-name))
         (entity (apply maker keys))
         (type (type-of entity)))
    (let ((table (gethash type db)))
      (when (null table)
        (let ((new-table (make-hash-table)))
          (setf (gethash type db) new-table
                table new-table)))
      (setf (gethash (funcall getter-id entity) table) entity))
    entity))

(defun get-component (shooter entity ctype)
  (let* ((db (shooter-database shooter))
         (components (gethash (intern (symbol-name ctype) :lsd) db)))
    (unless (null components)
      (gethash entity components))))

(defun init-shooter ()
  (let ((points ())
        (vels ())
        (dirs ())
        (vanishes ())
        (types ())
        (inputs ())
        (used ())
        (db (make-hash-table)))
    (flet ((make-player ()
             (let ((id (make-entity-id)))
               (push (make-entity db :otype :id id :name :player) types)
               (push (make-entity db :used :id id :bool t) used)
               (push (make-entity db :point :id id :x 400 :y 400) points)
               (push (make-entity db :direction :id id :r 0) dirs)
               (push (make-entity db :input :id id :u nil :d nil :l nil :r nil :z nil) inputs)))
           (make-enemy ()
             (let ((id (make-entity-id)))
               (push (make-entity db :otype :id id :name :enemy) types)
               (push (make-entity db :used :id id :bool t) used)
               (push (make-entity db :point :id id :x 400 :y 200) points)
               (push (make-entity db :direction :id id :r 0) dirs)))
           (make-bullet ()
             (let ((id (make-entity-id)))
               (push (make-entity db :otype :id id :name :bullet) types)
               (push (make-entity db :used :id id :bool nil) used)
               (push (make-entity db :point :id id
                                  :x (random 800)
                                  :y (random 600))
                     points)
               (push (make-entity db :velocity :id id
                                  :x (- (random 10) 5)
                                  :y (- (random 10) 5))
                     vels)
               (push (make-entity db :direction :id id :r 0) dirs)
               (push (make-entity db :vanish :id id :x 100 :y 100 :w 600 :h 400) vanishes))))
      (make-player)
      (make-enemy)
      (loop :for _ :from 0 :upto 1000 :do (make-bullet))
      (make-shooter :tick 0
                    :database db
                    :points (coerce points 'vector)
                    :vels (coerce vels 'vector)
                    :dirs (coerce dirs 'vector)
                    :vanishes (coerce vanishes 'vector)
                    :types (coerce types 'vector)
                    :inputs (coerce inputs 'vector)
                    :used used))))

(defun update-inputs (shooter &key (u nil u?) (d nil d?) (l nil l?) (r nil r?) (s nil s?) (z nil z?))
  (loop
    :for i :across (shooter-inputs shooter)
    :do (progn
          (when u? (setf (input-u i) u))
          (when d? (setf (input-d i) d))
          (when l? (setf (input-l i) l))
          (when r? (setf (input-r i) r))
          (when s? (setf (input-s i) s))
          (when z? (setf (input-z i) z)))))

(defun update-player (shooter)
  (let* ((player (find :player (shooter-types shooter) :key #'otype-name))
         (p (get-component shooter (otype-id player) :point))
         (i (get-component shooter (otype-id player) :input)))
    (let ((move (if (input-s) 3 5)))
      (when (input-u i) (incf (point-y p) (- move)))
      (when (input-d i) (incf (point-y p) move))
      (when (input-l i) (incf (point-x p) (- move)))
      (when (input-r i) (incf (point-x p) move)))))

(defun update-points (shooter)
  (loop
    :for p :across (shooter-points shooter)
    :do (let ((v (get-component shooter (point-id p) :velocity)))
          (unless (null v)
            (setf (point-x p) (+ (point-x p) (velocity-x v))
                  (point-y p) (+ (point-y p) (velocity-y v)))))))

(defun vanish-points (shooter)
  (loop
    :for v :across (shooter-vanishes shooter)
    :for p := (get-component shooter (vanish-id v) :point)
    :for u := (get-component shooter (vanish-id v) :used)
    :do (unless (or (null p) (null u))
          (when (or (< (point-x p) (vanish-x v))
                    (>= (point-x p) (+ (vanish-x v) (vanish-w v)))
                    (< (point-y p) (vanish-y v))
                    (>= (point-y p) (+ (vanish-y v) (vanish-h v))))
            (setf (used-bool u) nil)))))

(defun draw-points (shooter renderer)
  (sdl2:set-render-draw-color renderer 30 30 30 255)
  (loop
    :for p :across (shooter-points shooter)
    :when (let ((used (get-component shooter (point-id p) :used)))
            (and (not (null used)) (used-bool used)))
    :do (sdl2:render-draw-rect renderer
                               (sdl2:make-rect (- (floor (point-x p)) 3)
                                               (- (floor (point-y p)) 3)
                                               6 6))))

(defun shot-bullets (shooter)
  (let* ((e (find :enemy (shooter-types shooter) :key #'otype-name))
         (p (get-component shooter (otype-id e) :point)))
    (let ((n 20))
      (loop
        :for i := n :then (decf i)
        :while (plusp i)
        :do (let ((u (find nil (shooter-used shooter) :key #'used-bool)))
              (unless (null u)
                (setf (used-bool u) t)
                (let ((bp (get-component shooter (used-id u) :point))
                      (bv (get-component shooter (used-id u) :velocity)))
                  (unless (or (null bp) (null bv))
                    (setf (point-x bp) (point-x p)
                          (point-y bp) (point-y p)
                          (velocity-x bv) (* 5 (cos (* 2 pi (/ i n))))
                          (velocity-y bv) (* 5 (sin (* 2 pi (/ i n)))))))))))))

(defun main ()
  (sdl2:with-init (:everything)
    (sdl2:with-window (win :title (getf *game* :title)
                           :w (getf *game* :width)
                           :h (getf *game* :height))
      (sdl2:with-renderer (renderer win :index -1 :flags '(:accelerated))
        (let ((screen-rect (sdl2:make-rect 0 0 (getf *game* :width) (getf *game* :height)))
              (shooter (init-shooter)))
          (sdl2:with-event-loop (:method :poll)
            (:keydown (:keysym keysym)
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-up)
               (update-inputs shooter :u t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-down)
               (update-inputs shooter :d t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-left)
               (update-inputs shooter :l t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-right)
               (update-inputs shooter :r t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-lshift)
               (update-inputs shooter :s t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-z)
               (update-inputs shooter :z t))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-escape)
               (sdl2:push-event :quit)))
            (:keyup (:keysym keysym)
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-up)
               (update-inputs shooter :u nil))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-down)
               (update-inputs shooter :d nil))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-left)
               (update-inputs shooter :l nil))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-right)
               (update-inputs shooter :r nil))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-lshift)
               (update-inputs shooter :s nil))
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-z)
               (update-inputs shooter :z nil)))
            (:idle ()
             (sdl2:set-render-draw-color renderer 200 200 200 255)
             (sdl2:render-fill-rect renderer screen-rect)

             (draw-points shooter renderer)
             (update-points shooter)
             (update-player shooter)
             (vanish-points shooter)
             (when (zerop (mod (shooter-tick shooter) 12))
               (shot-bullets shooter))

             (incf (shooter-tick shooter))
             (sdl2:render-present renderer)

             (sdl2:delay (floor (/ 1000 60))))
            (:quit () t)))))))
