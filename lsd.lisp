(defpackage #:lsd
  (:use #:cl)
  (:export #:main))
(in-package #:lsd)

(defparameter *game*
  (list :title "Lazy Sweet Dream"
        :version (asdf:component-version (asdf:find-system :lsd))
        :width 800
        :height 600))

(defparameter *entity-count* 0)
(defun make-entity-id ()
  (prog1 *entity-count*
    (incf *entity-count*)))

(defstruct point id x y)
(defstruct velocity id x y)
(defstruct direction id r)
(defstruct otype id name)
(defstruct input id u d l r z)
(defstruct used id bool)

(defstruct shooter
  tick
  points vels dirs types inputs used)

(defun init-shooter ()
  (let ((points ())
        (vels ())
        (dirs ())
        (types ())
        (inputs ())
        (used ()))
    (flet ((make-player ()
             (let ((id (make-entity-id)))
               (push (make-otype :id id :name :player) types)
               (push (make-used :id id :bool t) used)
               (push (make-point :id id :x 400 :y 400) points)
               (push (make-direction :id id :r 0) dirs)
               (push (make-input :id id :u nil :d nil :l nil :r nil :z nil) inputs)))
           (make-enemy ()
             (let ((id (make-entity-id)))
               (push (make-otype :id id :name :enemy) types)
               (push (make-used :id id :bool t) used)
               (push (make-point :id id :x 400 :y 200) points)
               (push (make-direction :id id :r 0) dirs)))
           (make-bullet ()
             (let ((id (make-entity-id)))
               (push (make-otype :id id :name :bullet) types)
               (push (make-used :id id :bool nil) used)
               (push (make-point :id id
                                 :x (random 800)
                                 :y (random 600))
                     points)
               (push (make-velocity :id id
                                    :x (- (random 10) 5)
                                    :y (- (random 10) 5))
                     vels)
               (push (make-direction :id id :r 0) dirs))))
      (make-player)
      (make-enemy)
      (loop :for _ :from 0 :upto 1000 :do (make-bullet))
      (make-shooter :tick 0
                    :points (coerce points 'vector)
                    :vels (coerce vels 'vector)
                    :dirs (coerce dirs 'vector)
                    :types (coerce types 'vector)
                    :inputs (coerce inputs 'vector)
                    :used used))))

(defun update-points (shooter)
  (loop
    :for p :across (shooter-points shooter)
    :do (let* ((id (point-id p))
               (v (find id (shooter-vels shooter) :key #'velocity-id)))
          (unless (null v)
            (setf (point-x p) (+ (point-x p) (velocity-x v))
                  (point-y p) (+ (point-y p) (velocity-y v)))))))

(defun draw-points (shooter renderer)
  (sdl2:set-render-draw-color renderer 30 30 30 255)
  (loop
    :for p :across (shooter-points shooter)
    :when (let ((a (find (point-id p) (shooter-used shooter) :key #'used-id)))
            (used-bool a))
    :do (sdl2:render-draw-rect renderer
                               (sdl2:make-rect (- (floor (point-x p)) 3)
                                               (- (floor (point-y p)) 3)
                                               6 6))))

(defun shot-bullets (shooter)
  (let* ((e (find :enemy (shooter-types shooter) :key #'otype-name))
         (id (otype-id e)))
    (unless (null e)
      (let ((p (find id (shooter-points shooter) :key #'point-id)))
        (unless (null p)
          (let ((n 20))
            (loop
              :for i := n :then (decf i)
              :while (plusp i)
              :do (let ((u (find nil (shooter-used shooter) :key #'used-bool)))
                    (unless (null u)
                      (setf (used-bool u) t)
                      (let ((bp (find (used-id u) (shooter-points shooter) :key #'point-id))
                            (bv (find (used-id u) (shooter-vels shooter) :key #'velocity-id)))
                        (unless (or (null bp) (null bv))
                          (setf (point-x bp) (point-x p)
                                (point-y bp) (point-y p)
                                (velocity-x bv) (* 3 (cos (* 2 pi (/ i n))))
                                (velocity-y bv) (* 3 (sin (* 2 pi (/ i n))))))))))))))))

(defun main ()
  (sdl2:with-init (:everything)
    (sdl2:with-window (win :title (getf *game* :title)
                           :w (getf *game* :width)
                           :h (getf *game* :height))
      (sdl2:with-renderer (renderer win :index -1 :flags '(:accelerated))
        (let ((screen-rect (sdl2:make-rect 0 0 (getf *game* :width) (getf *game* :height)))
              (shooter (init-shooter)))
          (sdl2:with-event-loop (:method :poll)
            (:keyup (:keysym keysym)
             (when (sdl2:scancode= (sdl2:scancode-value keysym) :scancode-escape)
               (sdl2:push-event :quit)))
            (:idle ()
             (sdl2:set-render-draw-color renderer 200 200 200 255)
             (sdl2:render-fill-rect renderer screen-rect)
             (draw-points shooter renderer)
             (update-points shooter)
             (when (zerop (mod (shooter-tick shooter) 12))
               (shot-bullets shooter))
             (incf (shooter-tick shooter))
             (sdl2:render-present renderer)

             (sdl2:delay (floor (/ 1000 60))))
            (:quit () t)))))))
